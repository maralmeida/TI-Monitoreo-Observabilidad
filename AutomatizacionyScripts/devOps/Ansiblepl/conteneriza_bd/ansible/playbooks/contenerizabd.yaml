- name: Contenerización de Base de Datos con Ansible via bak-python script y Docker Compose
  hosts: dbservers
  become: yes
  become_method: sudo
  
  vars:
    BACKUPBD_NAME: "SitioPruebas_2026-01-28_1640.bak"
    REPOPATH_BACKUP_BD: "contenerizabd"
    DEST_PATH: "/var/opt/mssql"
    RESTORE_SCRIPT: "restaurabdmssql.py"
    LOG_EVIDENCIA: "/var/opt/mssql/logs/ansible_mssql_deploydocker.log"

  tasks:

    - name: "Revisión estado anterior"
      shell: |
        echo "--- Estado pre-despliegue ---" > {{ LOG_EVIDENCIA }}
        echo "Fecha: $(date)" >> {{ LOG_EVIDENCIA }}
        echo "Contenedores mssql actuales:" >> {{ LOG_EVIDENCIA }}
        docker ps -a --filter "name=mssql-server-sitiosapp" >> {{ LOG_EVIDENCIA }}
      ignore_errors: yes

    - name: "0. Preparar entorno para actualización"
      shell: |
        # Solo bajamos el contenedor, NO borramos volúmenes (-v)
        cd {{ DEST_PATH }}/scripts && docker compose down || true
      ignore_errors: yes

    - name: "1. Crear estructura de directorios (si no existe)"
      file:
        path: "{{ item }}"
        state: directory
        # Importante: El ID 10001 es el usuario 'mssql' dentro del contenedor.
        # Esto permite que el motor SQL tenga permisos para leer el .bak
        owner: "10001" 
        group: "root"
        mode: '0775'
        recurse: yes
      loop:
        - "{{ DEST_PATH }}"
        - "{{ DEST_PATH }}/data"
        - "{{ DEST_PATH }}/backup"
        - "{{ DEST_PATH }}/scripts"
        - "{{ DEST_PATH }}/logs"
        
    - name: "2. Instalar dependencias basicas en el Host"
      apt:
        name: 
          - python3
          # python3-pip y pyodbc ya no son obligatorios porque uso el script de 'docker exec'
        state: present
        update_cache: yes


    - name: "3. Checkout de respaldo de bd al servidor"
      ansible.builtin.copy:
        src: "{{ REPOPATH_BACKUP_BD }}/{{ BACKUPBD_NAME }}" 
        dest: "{{ DEST_PATH }}/backup/{{ BACKUPBD_NAME }}"
        owner: "10001"
        group: "root"
        mode: '0664'

    - name: "4. Checkout de config files al servidor"
      ansible.builtin.copy:
        src: "{{ item.src }}"
        dest: "{{ DEST_PATH }}/{{ item.dest }}" 
      loop:
        - { src: "{{ REPOPATH_BACKUP_BD }}/docker-compose.yaml", dest: "scripts/docker-compose.yaml" }
        - { src: "{{ REPOPATH_BACKUP_BD }}/{{ RESTORE_SCRIPT }}", dest: "scripts/{{ RESTORE_SCRIPT }}" }

    - name: "5. Levantar el contenedor de base de datos"
      community.docker.docker_compose_v2:
        project_src: "{{ DEST_PATH }}/scripts"
        state: present

    - name: "5.1 ESPERA TÉCNICA: Aguardando inicio del motor SQL (60 segundos)" 
      pause:
        seconds: 60
        prompt: "Esperando a que SQL Server termine de arrancar los servicios internos..."

    - name: "5.2 Validar si la base de datos ya existe físicamente"
      stat:
        path: "{{ DEST_PATH }}/data/SitioPruebas.mdf"
      register: db_status

    - name: "6. Ejecutar restauración en docker (Solo si es instalación nueva o se borró el volumen)"
      shell: |
        # Ejecutamos el script que orquestará el 'docker exec'
        python3 {{ DEST_PATH }}/scripts/{{ RESTORE_SCRIPT }}
      register: restore_out
      # Esta es la clave: Si el archivo .mdf existe, se salta esta tarea
      when: not db_status.stat.exists 

    - name: 7. Debug de Restauración
      debug:
        var: restore_out.stdout_lines
      # Agrega 'defined' para que no falle si la tarea 6 se saltó
      when: db_status.stat.exists == False and restore_out is defined 

    - name: "8. Registro de despligue (Post-Check)"
      shell: |
        echo "--- REPORTE DE DESPLIEGUE ---" > {{ DEST_PATH }}/log/evidencia_despliegue.log
        echo "Fecha: $(date)" >> {{ DEST_PATH }}/log/evidencia_despliegue.log
        echo "Estado: {{ 'Base de datos ya existente (Persistente)' if db_status.stat.exists else 'Restauración realizada' }}" >> {{ DEST_PATH }}/evidencia_despliegue.log
        docker ps --filter "name=mssql-server-sitiosapp" >> {{ DEST_PATH }}/log/evidencia_despliegue.log
      ignore_errors: yes

    - name: "9. Recupera log"
      fetch:
        src: "{{ DEST_PATH }}/log/evidencia_despliegue.log"
        # guardará logs en con nombre del host en control node en carpeta default si no se especifica
        dest: "./logs/restaurabd_{{ inventory_hostname }}.log"
        flat: yes